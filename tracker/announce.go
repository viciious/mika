package tracker

import (
	"bytes"
	"github.com/chihaya/bencode"
	"github.com/gin-gonic/gin"
	"github.com/viciious/mika/config"
	"github.com/viciious/mika/consts"
	"github.com/viciious/mika/metrics"
	"github.com/viciious/mika/store"
	"github.com/viciious/mika/util"
	"github.com/pkg/errors"
	log "github.com/sirupsen/logrus"
	"net"
	"sync/atomic"
	"time"
)

// Represents an announce received from the bittorrent client
//
// TODO use gin binding func?
type announceRequest struct {
	Compact bool // Force compact always?

	// The total amount downloaded (since the client sent the 'started' event to the tracker) in
	// base ten ASCII. While not explicitly stated in the official specification, the consensus is that
	// this should be the total number of bytes downloaded.
	Downloaded uint32

	// The number of bytes this peer still has to download, encoded in base ten ascii.
	// Note that this can't be computed from downloaded and the file length since it
	// might be a resume, and there's a chance that some of the downloaded data failed an
	// integrity check and had to be re-downloaded.
	Left uint32

	// The total amount uploaded (since the client sent the 'started' event to the tracker) in base ten
	// ASCII. While not explicitly stated in the official specification, the consensus is that this should
	// be the total number of bytes uploaded.
	Uploaded uint32

	Corrupt uint32

	// This is an optional key which maps to started, completed, or stopped (or empty,
	// which is the same as not being present). If not present, this is one of the
	// announcements done at regular intervals. An announcement using started is sent
	// when a download first begins, and one using completed is sent when the download
	// is complete. No completed is sent if the file was complete when started. Downloaders
	// send an announcement using stopped when they cease downloading.
	Event consts.AnnounceType

	//  Optional. The true IP address of the client machine, in dotted quad format or rfc3513
	// defined hexed IPv6 address. Notes: In general this parameter is not necessary as the address
	// of the client can be determined from the IP address from which the HTTP request came.
	// The parameter is only needed in the case where the IP address that the request came in on
	// is not the IP address of the client. This happens if the client is communicating to the
	// tracker through a proxy (or a transparent web proxy/cache.) It also is necessary when both the
	// client and the tracker are on the same local side of a NAT gateway. The reason for this is that
	// otherwise the tracker would give out the internal (RFC1918) address of the client, which is not
	// routable. Therefore the client must explicitly state its (external, routable) IP address to be
	// given out to external peers. Various trackers treat this parameter differently. Some only honor
	// it only if the IP address that the request came in on is in RFC1918 space. Others honor it
	// unconditionally, while others ignore it completely. In case of IPv6 address (e.g.: 2001:db8:1:2::100)
	// it indicates only that client can communicate via IPv6.
	IP   net.IP
	IPv6 bool
	// urlencoded 20-byte SHA1 hash of the value of the info key from the Metainfo file. Note that the
	// value will be a bencoded dictionary, given the definition of the info key above.
	InfoHash store.InfoHash

	// Optional. Number of peers that the client would like to receive from the tracker. This value is
	// permitted to be zero. If omitted, typically defaults to 50 peers.
	NumWant uint

	// Required for private tracker use. Authentication key to authenticate requests
	Passkey string

	// urlencoded 20-byte string used as a unique ID for the client, generated by the client at startup.
	// This is allowed to be any value, and may be binary data. There are currently no guidelines for
	// generating this peer ID. However, one may rightly presume that it must at least be unique for
	// your local machine, thus should probably incorporate things like process ID and perhaps a timestamp
	// recorded at startup. See peer_id below for common client encodings of this field.
	PeerID store.PeerID

	// The port number that the client is listening on. Ports reserved for BitTorrent are typically
	// 6881-6889. Clients may choose to give up if it cannot establish a port within this range.
	Port uint16

	// Optional. If a previous announce contained a tracker id, it should be set here.
	TrackerID string

	Key string

	CryptoLevel consts.CryptoLevel
}

// Parse the query string into an announceRequest struct
func newAnnounce(c *gin.Context) (*announceRequest, errCode) {
	q, err := queryStringParser(c.Request.URL.RawQuery)
	if err != nil {
		return nil, msgMalformedRequest
	}
	infoHashStr, ihExists := q.Params[paramInfoHash]
	if !ihExists {
		return nil, msgInvalidInfoHash
	}
	var infoHash store.InfoHash
	if err := store.InfoHashFromString(&infoHash, infoHashStr); err != nil {
		log.Warnf("Got malformed info_hash: %s", infoHashStr)
		return nil, msgInvalidInfoHash
	}
	peerID, exists := q.Params[paramPeerID]
	if !exists || len(peerID) != 20 {
		return nil, msgInvalidPeerID
	}
	ipAddr, ipv6, err2 := getIP(q, config.Tracker.AllowClientIP, c)
	if err2 != nil {
		log.Errorf("Failed to parse client ip: %s", c.Request.RemoteAddr)
		return nil, msgMalformedRequest
	}
	if !config.Tracker.AllowNonRoutable && util.IsPrivateIP(ipAddr) {
		log.Warnf("Attempt to use non-routable IP value: %s", ipAddr.String())
		return nil, msgMalformedRequest
	}
	port := getUint16Key(q, paramPort, 0)
	if port < 1024 {
		// Don't allow privileged ports which require root to bind to on unix
		return nil, msgInvalidPort
	}
	cryptoLevel := consts.Unencrypted
	if getBoolKey(q, paramRequireCrypto, false) {
		cryptoLevel = consts.Required
	} else if getBoolKey(q, paramSupportCrypto, false) {
		cryptoLevel = consts.Supported
	}
	return &announceRequest{
		Compact:     true, // Ignored and always set to true
		Corrupt:     getUint32Key(q, paramCorrupt, 0),
		Downloaded:  getUint32Key(q, paramDownloaded, 0),
		Event:       consts.ParseAnnounceType(q.Params[paramEvent]),
		IPv6:        ipv6,
		IP:          ipAddr,
		InfoHash:    infoHash,
		Left:        getUint32Key(q, paramLeft, 0),
		NumWant:     getUintKey(q, paramNumWant, 30),
		PeerID:      store.PeerIDFromString(peerID),
		Port:        port,
		Key:         q.Params[paramKey],
		Uploaded:    getUint32Key(q, paramUploaded, 0),
		CryptoLevel: cryptoLevel,
	}, msgOk
}

// The meaty bits.
// NOTE we ONLY support compact response formats (binary format) by design even though its
// technically breaking the protocol specs.
// There is no reason to support the older less efficient model for private needs
func announce(c *gin.Context) {
	// Check that the user is valid before parsing anything
	start := time.Now()
	atomic.AddInt64(&metrics.AnnounceTotal, 1)
	pk := c.Param("passkey")
	var usr store.User
	if valid := preFlightChecks(&usr, pk, c); !valid {
		oops(c, msgInvalidAuth)
		atomic.AddInt64(&metrics.AnnounceStatusUnauthorized, 1)
		return
	}
	// Parse the announce into an announceRequest
	req, code := newAnnounce(c)
	if code != msgOk {
		oops(c, code)
		atomic.AddInt64(&metrics.AnnounceStatusMalformed, 1)
		return
	}
	// TODO save this check
	if !ClientWhitelisted(req.PeerID) {
		oops(c, msgBadClient)
		return
	}
	if pk == "" && config.Tracker.Public {
		// Use client key to track user stats for public mode
		pk = req.Key
	}
	// Get & Validate the torrent associated with the info_hash supplies
	tor, errGet := TorrentGet(req.InfoHash, false)
	if errGet != nil || tor.IsDeleted {
		if !errors.Is(errGet, consts.ErrInvalidInfoHash) {
			log.Errorf("Error fetching torrent: %v", errGet)
			oops(c, msgGenericError)
			return
		}
		if config.Tracker.AutoRegister {
			newTor := store.NewTorrent(req.InfoHash)
			if err := TorrentAdd(&newTor); err != nil {
				log.Errorf("Failed to auto register torrent: %s", err.Error())
				oops(c, msgGenericError)
				return
			}
			tor = &newTor
		} else {
			log.Debugf("No torrent found matching: %x", req.InfoHash.Bytes())
			oops(c, msgInvalidInfoHash)
			atomic.AddInt64(&metrics.AnnounceStatusInvalidInfoHash, 1)
			return
		}
	}
	// If disabled and reason is set, the reason is returned to the client
	// This is mostly useful for when a torrent has been "trumped" by another torrent so it
	// should be downloaded instead
	//
	// TODO send this as a "warning message" field of a normal announce response instead?
	if !tor.IsEnabled && tor.Reason != "" {
		log.Debugf("Torrent found but is disabled: %x", req.InfoHash.Bytes())
		c.Data(int(msgInvalidInfoHash), gin.MIMEPlain, responseError(tor.Reason))
		return
	}
	peer, err := tor.Peers.Get(req.PeerID)
	if err != nil {
		if err == consts.ErrInvalidPeerID {
			// Create a new peer for the swarm
			peer = store.NewPeer(usr.UserID, req.PeerID, req.IP, req.Port)
			// Dont add download/upload stats because they would be doubled if applied in the
			// state update. Left is set because its always a static value being set and a (safe) data race
			// can occur for counting seeder/leecher states
			peer.Client = store.ClientString(req.PeerID).String()
			// TODO allow this to be updated in the perm storage when a client changes settings
			peer.CryptoLevel = req.CryptoLevel
			l := geodb.GetLocation(peer.IP)
			peer.Location = l.LatLong
			peer.ASN = l.ASN
			peer.AS = l.AS
			peer.CountryCode = l.ISOCode
			tor.Peers.Add(peer)
		} else {
			oops(c, msgGenericError)
			return
		}
	} else {
		peer.AnnounceLast = time.Now()
	}
	atomic.SwapUint32(&peer.Left, req.Left)
	peersFound, err2 := tor.Peers.GetN(config.Tracker.MaxPeers)
	if err2 != nil {
		log.Errorf("Could not read peers from swarm: %s", err2.Error())
		oops(c, msgGenericError)
		return
	}
	dict := bencode.Dict{
		"complete":     tor.Seeders,
		"incomplete":   tor.Leechers,
		"interval":     int(config.Tracker.AnnounceIntervalParsed.Seconds()),
		"min interval": int(config.Tracker.AnnounceIntervalMinimumParsed.Seconds()),
	}
	// TODO IP.To16() != nil validation for v4 in v6 addresses
	if !req.IPv6 || (req.IPv6 && !config.Tracker.IPv6Only) {
		dict["peers"] = makeCompactPeers(peersFound, peer.PeerID, false, req.CryptoLevel)
	}
	if req.IPv6 {
		dict["peers6"] = makeCompactPeers(peersFound, peer.PeerID, true, req.CryptoLevel)
	}
	var outBytes bytes.Buffer
	if err := bencode.NewEncoder(&outBytes).Encode(dict); err != nil {
		oops(c, msgGenericError)
		return
	}
	updateStates(req, peer, tor, &usr)
	c.Data(int(msgOk), gin.MIMEPlain, outBytes.Bytes())
	metrics.AddAnnounceTime(time.Since(start).Nanoseconds())
	tor.Log().Debug("Announced")
}

func updateStates(req *announceRequest, peer *store.Peer, tor *store.Torrent, user *store.User) {
	switch req.Event {
	case consts.PAUSED:
		if !peer.Paused {
			atomic.AddUint32(&tor.Seeders, 1)
		}
	case consts.STARTED:
		if peer.Left == 0 {
			atomic.AddUint32(&tor.Seeders, 1)
		} else {
			atomic.AddUint32(&tor.Leechers, 1)
		}
	case consts.COMPLETED:
		atomic.AddUint32(&tor.Snatches, 1)
		atomic.AddUint32(&tor.Seeders, 1)
		if tor.Leechers >= 1 {
			atomic.SwapUint32(&tor.Leechers, tor.Leechers-1)
		}
	case consts.STOPPED:
		// Paused considered a seeder
		if peer.Paused || peer.Left == 0 {
			if tor.Seeders > 0 {
				atomic.SwapUint32(&tor.Seeders, tor.Seeders-1)
			}
		} else {
			if tor.Leechers > 0 {
				atomic.SwapUint32(&tor.Leechers, tor.Leechers-1)
			}
		}
		tor.Peers.Remove(peer.PeerID)
		//if err := peerDelete(u.InfoHash, u.PeerID); err != nil {
		//	log.Errorf("Could not remove peer from swarm: %s", err.Error())
		//}
	}
	atomic.AddInt64(&metrics.AnnounceStatusOK, 1)
	atomic.AddUint32(&peer.Announces, 1)
	atomic.SwapUint32(&peer.Left, req.Left)
	atomic.AddUint64(&peer.Downloaded, uint64(req.Downloaded))
	atomic.AddUint64(&peer.Uploaded, uint64(req.Uploaded))
	atomic.AddUint64(&tor.Announces, 1)
	atomic.AddUint64(&tor.Uploaded, uint64(float64(req.Uploaded)*tor.MultiUp))
	atomic.AddUint64(&tor.Downloaded, uint64(float64(req.Downloaded)*tor.MultiDn))
	atomic.AddUint64(&tor.UploadedReal, uint64(req.Uploaded))
	atomic.AddUint64(&tor.DownloadedReal, uint64(req.Downloaded))
	atomic.AddUint32(&tor.Writes, 1)
	atomic.AddUint32(&user.Writes, 1)
}

// Generate a compact peer field array containing the byte representations
// of a peers IP+Port appended to each other
func makeCompactPeers(swarm []*store.Peer, skipID store.PeerID, v6 bool, cl consts.CryptoLevel) []byte {
	var buf bytes.Buffer
	for _, peer := range swarm {
		if cl == consts.Required {
			if !(peer.CryptoLevel == consts.Required || peer.CryptoLevel == consts.Supported) {
				continue
			}
		}
		if peer.PeerID == skipID {
			// Skip the peers own peer_id
			continue
		}
		if v6 && peer.IPv6 {
			buf.Write(peer.IP.To16())
			buf.Write([]byte{byte(peer.Port >> 8), byte(peer.Port & 0xff)})
		} else if !v6 && !peer.IPv6 {
			buf.Write(peer.IP.To4())
			buf.Write([]byte{byte(peer.Port >> 8), byte(peer.Port & 0xff)})
		}

	}
	return buf.Bytes()
}
